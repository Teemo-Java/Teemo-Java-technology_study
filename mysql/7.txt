主键可以通过聚簇索引来查找，但是如果是其他一个或多个字段来查找呢？ 

那么我们就需要创建其他索引了，这个索引可能是单列的也可能是联合的，这个索引也对应一颗B+树。叶子节点也是数据页 但是这个数据页仅仅存放主键和你建立索引的字段 ,

比如我们建立的索引是idx_name_age(name,age,hobby) ,那么叶子节点存放的就是 id，name，age，hobby 。非叶子节点存放的就是子节点编号和子节点最小的name，age，hobby 值，

这里节点的排序规则值得说一下，和聚簇索引不同的是，聚簇索引就直接比较的是主键值，这里比较的就是索引列的值了。
如果name值一样，那就比较age值，如果age值也一样，那就比较hobby值，hobby值也一样，那就根据主键顺序来排列了。所以到这里 应该就明白了"为什么使用联合索引有个最左匹配原则的限制吧?",因为索引树在排列节点的时候就是按照从左到右依次比较的呀。

那么我们通过select * from table where name = '张三' and age = 18。整个查询过程就是先去idx_name_age对应的B+树，从上往下一直搜索，直到找到叶子节点的id，
然后通过拿到的id再去聚簇索引中取值，这个过程叫"回表"。聚簇索引最靠近真实数据，所以也叫一级索引。其他索引都叫二级索引



使用索引要点：
一个表对应索引不是越多越好的，索引越多，索引所占据的空间就越大，在增删改数据的时候 维护索引树的压力就越大。
一般规则如：不要使用查询列不要使用函数，not in，避免隐式转换等等。
where条件使用联合索引(name,age,hobby)需要满足最左匹配规则 (这个不知道的话就自己去百度学习吧)

排序和分组的情况
排序的时候 字段尽量建立索引，否则的话 mysql直接使用filesort来排序 ，效率比较低。
排序时，也是需要满足最左匹配原则的，order by name ,age hobby 最好要么全部升序要么全部降序，否则mysql也不会使用索引来排序
分组group by的时候与使用order by的原理和条件几乎一样

select * ：为什么尽量不要写select *？一方面网络开销，查询列多了 自然网络压力就大了，另外 select * 的话就算使用到索引，走索引之后还要去回表查询一次，mysql有时候会觉得这样扫描两个索引还不如直接走全表查询呢？
另外在查询的时候可能需要查询的列就在联合索引中 ，但是因为写了select *,那么就放弃了直接从索引取数据，还要走聚簇索引取数据，放弃了覆盖索引。

建立索引要点
查询，排序与分组：where条件、order by条件以及group by条件 中的列考虑建立索引，联合索引与单列索引优先使用联合索引
区分度：尽量使用那些区分度大的列作为索引列，如sex这种这种列，区分度小 发挥不了二分查找优势，就尽量不要建立索引了。
前缀索引：如果需要在name varchar(255)这样的列使用索引，可以使用KEY my_index(name(20),age,course）这种前缀索引，这个时候索引树中仅仅有前20个字符串。使用索引的时候 也仅仅能使用前20个字符串
74 - 80 不需要作图