15
对象优先在新生代创建，等新生代内存越来越满时，触发一次Young GC，这是一种触发时机
那么Young GC时，哪些对象不能被回收呢。
总的来说 就是与GC Roots关联的对象不能被回收。
1 局部变量(方法内的变量)就是可以作为GC Roots，所以Young GC时，正在被局部变量指向的对象不能被回收
2 静态变量也可以看做是一种GC Roots，所以Young GC时， 静态变量指向的对象不能被回收

强，软，弱，虚
强：Test a  = new Test();  这种就是强引用，Young GC时 这种变量指向的对象不会被回收
软：SoftReference，如果Young GC之后内存依然不够用，那么软引用也会被回收，如果够用 那么就不会被回收。
弱：WeakReference，Young GC时 直接将其回收
虚：PhantomReference 这个用的很少

finalize()方法，在对象被回收时调用这个订单，如果在这里将对象指向一个static变量，那么就挽救了这个对象 不被回收。

16

新生代使用优化后的复制算法
将新生代分为三块，Eden 和两个Survivor，8:1:1，(这个比例是可以调整的)
使用时：对象在Eden区创建，一块Survivor存放的是上一次回收后的对象，当Eden 快满时，触发一次Young GC，将Eden 和Survivor中存活的对象放入到另一块Survivor区中，然后对象创建还是在Eden区创建，
这时又是Eden和一块Survivor被使用，另一块Survivor空闲，这样就保证了90%的内存可以被使用，比那种将内存一分为二的复制方法更好。

这里会存在几个问题
万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？
万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？
到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？


17 - 18，18的案例可以梳理一下
新生代对象进入老年代区域的几种途径
1 新生代的对象在新生代经过15次Minor GC后，其对象年龄达到15岁了，那么这些对象就会被转移到老年代中去。(这个比例是可以调整的)
2 动态对象年龄判断：
如果Survivor对象中的年龄1的对象+年龄2的对象+...+年龄n的对象所占用的内存>=Survivor内存大小的50%，那么年龄>n的对象会被放入都老年代区域
3 大对象直接进入老年代
参数-XX:PretenureSizeThreshold可以对象的大小，如果对象创建的时候大于这个值，那么这个对象就直接放入到老年代，不经过新生代。
这样做的原因是如果这么大的对象可能在新生代复制来复制去，经历15次。是很耗费性能的。所以就直接放入到老年代去了。
4 假设新生代各区域大小，Eden:800m,Survivor1:100m,Survivor2:100m。
假设在一次Minor GC后，在Eden区+一块Survivor区的剩余存活对象大于Survivor区大小 假设是150m，此时是没法放入到Survivor区中去的，那么直接将这些对象放入到老年代中去。

老年代空间分配担保原则
如果存活对象的大小大于Survivor的大小，也大于老年代所剩余可用内存大小，怎么办？
第一步：在进行Minor GC之前，JVM会检查老年代可用内存，可用内存是否大于新生代对象总和(极端情况所有对象都存活) 如果大于，那么可以直接进行Minor GC了，如果否那么第二步
第二步：看一下是否设置了参数 -XX:HandlePromotionFailure如果设置了，那么进行第三步，如果否 那么直接进行一次Full GC(Full GC中会包含Minor GC+老年代回收)。(JDK 1.6或之前才会进行整改判断，1.63之后直接进入下一步，相当于参数设置为true了)
第三步：判断老年代可使用的内存是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果是 那么冒险进行一次Minor GC，如果否那么进行Full GC
第四步，进行Minor GC后，存活内存如果<Survivor大小，那么直接进入Survivor，如果>Survivor<老年代,那么进入老年代，如果>老年代，那么也进行一次Full GC
第五步，如果Full GC后老年代还是不能存放存活对象，那么这个时候就是OOM异常了。

老年代回收算法采用 标记-整理 算法，这个算法的回收效率比新生代效率慢10倍。从这里可以看出来 所谓JVM优化，优化的方向就是尽量别让对象频繁的进入老年代频繁的对老年代进行回收。
另外：也要多给一点内存给新生代，避免新生代进行频繁回收。合理设置新生代内存大小，避免对象直接通过动态年龄的方式直接进入老年代，撑爆老年代，避免Full GC。比如：
加大分代年龄，比如默认15加到30; 
修改新生代老年代比例，比如新生代老年代比例改成2:1 
修改e区和s区比例，比如改成6:2:2



垃圾回收器简介
Serial + Serial old 
ParNew + CMS
G1

