15
对象优先在新生代创建，等新生代内存越来越满时，触发一次Young GC，这是一种触发时机
那么Young GC时，哪些对象不能被回收呢。
总的来说 就是与GC Roots关联的对象不能被回收。
1 局部变量(方法内的变量)就是可以作为GC Roots，所以Young GC时，正在被局部变量指向的对象不能被回收
2 静态变量也可以看做是一种GC Roots，所以Young GC时， 静态变量指向的对象不能被回收

强，软，弱，虚
强：Test a  = new Test();  这种就是强引用，Young GC时 这种变量指向的对象不会被回收
软：SoftReference，如果Young GC之后内存依然不够用，那么软引用也会被回收，如果够用 那么就不会被回收。
弱：WeakReference，Young GC时 直接将其回收
虚：PhantomReference 这个用的很少

finalize()方法，在对象被回收时调用这个订单，如果在这里将对象指向一个static变量，那么就挽救了这个对象 不被回收。

16

新生代使用优化后的复制算法
将新生代分为三块，Eden 和两个Survivor，8:1:1
使用时：对象在Eden区创建，一块Survivor存放的是上一次回收后的对象，当Eden 快满时，触发一次Young GC，将Eden 和Survivor中存活的对象放入到另一块Survivor区中，然后对象创建还是在Eden区创建，
这时又是Eden和一块Survivor被使用，另一块Survivor空闲，这样就保证了90%的内存可以被使用，比那种将内存一分为二的复制方法更好。
这里会存在几个问题
万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？
万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？
到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？


